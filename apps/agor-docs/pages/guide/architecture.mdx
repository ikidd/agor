# Architecture Overview

Agor is a **multi-client agent orchestration platform** with real-time collaboration, built on a local-first daemon architecture.

## System Architecture

```mermaid
graph TB
    subgraph Clients
        CLI["<b>CLI</b><br/>oclif"]
        UI["<b>Web UI</b><br/>React + Ant Design"]
        Desktop["<b>Desktop</b><br/>future: Electron/Tauri"]
    end

    Client["<b>Feathers Client</b><br/>REST + WebSocket"]

    subgraph "Agor Daemon"
        Feathers["<b>FeathersJS Server</b>"]

        MCP["<b>MCP HTTP Endpoint</b><br/>POST /mcp?sessionToken=..."]

        Services["<b>Services</b><br/>Sessions, Tasks, Messages<br/>Boards, Worktrees, Repos<br/>Users, MCP, Context, Health"]

        AgentSDKs["<b>Agent SDKs</b><br/>Claude, Codex, Gemini"]

        ORM["<b>Drizzle ORM</b><br/>Type-safe queries"]
    end

    subgraph Storage
        DB[("<b>LibSQL Database</b><br/>~/.agor/agor.db")]
        Git["<b>Git Worktrees</b><br/>~/.agor/worktrees/"]
        Config["<b>Config</b><br/>~/.agor/config.yaml"]
    end

    CLI --> Client
    UI --> Client
    Desktop -.-> Client

    Client <-->|REST + WebSocket| Feathers

    Feathers --> Services
    Feathers --> MCP
    MCP --> Services
    Services --> ORM
    Services --> AgentSDKs
    AgentSDKs -.->|JSON-RPC 2.0| MCP

    ORM --> DB
    Services --> Git
    Services --> Config
```

## Technology Stack

### Backend
- **[FeathersJS](https://feathersjs.com/)** - Unified REST + WebSocket API framework
- **[Drizzle ORM](https://orm.drizzle.team/)** - Type-safe database layer with LibSQL support
- **[LibSQL](https://github.com/tursodatabase/libsql)** - Local SQLite-compatible database (future: cloud sync via Turso)
- **[simple-git](https://github.com/steveukx/simple-git)** - Git operations for worktree management

### Frontend
- **[React 18](https://react.dev/)** + **[Vite](https://vitejs.dev/)** - Fast development with HMR
- **[Ant Design](https://ant.design/)** - Enterprise UI component library
- **[React Flow](https://reactflow.dev/)** - Interactive session canvas with drag-and-drop
- **[Socket.IO Client](https://socket.io/)** - Real-time WebSocket connection

### CLI
- **[oclif](https://oclif.io/)** - Enterprise-grade CLI framework

### Agent Integration
- **[@anthropic-ai/claude-agent-sdk](https://github.com/anthropics/claude-agent-sdk)** - Claude Code capabilities with CLAUDE.md auto-loading
- **[OpenAI SDK](https://github.com/openai/openai-node)** - Codex integration with custom permission system
- **[Google Generative AI SDK](https://ai.google.dev/)** - Gemini integration (beta)

## Real-Time Multiplayer

Agor achieves multiplayer collaboration through **FeathersJS real-time events**:

### WebSocket Event Flow

```mermaid
sequenceDiagram
    participant U1 as User 1 (Browser)
    participant U2 as User 2 (CLI)
    participant D as Daemon
    participant DB as Database

    U1->>D: Create session (WebSocket)
    D->>DB: INSERT session
    DB-->>D: Session created
    D->>U1: 'created' event
    D->>U2: 'created' event (broadcast)

    U2->>D: Update session position
    D->>DB: UPDATE session
    D->>U1: 'patched' event (broadcast)
    D->>U2: 'patched' event

    Note over U1,U2: All connected clients<br/>receive real-time updates
```

**Key Features:**
- **Automatic broadcasting** - FeathersJS emits events to all connected clients
- **Service-level events** - `created`, `patched`, `removed`, `updated`
- **Custom events** - Cursor position, presence updates (100ms throttle)
- **Optimistic UI** - React hooks listen to events and update state immediately

## Core Services

The daemon exposes 12 FeathersJS services via REST and WebSocket:

| Service | Purpose | Key Operations |
|---------|---------|----------------|
| **sessions** | Agent sessions with genealogy | CRUD, fork, spawn, prompt execution |
| **tasks** | Work units within sessions | CRUD, completion tracking |
| **messages** | Conversation history | CRUD, bulk insert, streaming |
| **boards** | Spatial session organization | CRUD, session positioning |
| **worktrees** | Git worktree isolation | Create, list, delete worktrees |
| **repos** | Git repository management | Clone, list, worktree operations |
| **users** | User accounts & auth | CRUD, JWT authentication |
| **mcp-servers** | MCP server configs | CRUD, capability queries |
| **session-mcp-servers** | Session MCP links | Associate MCP servers with sessions |
| **context** | Context file browser | Read-only access to context/ files |
| **terminals** | WebSocket terminal proxy | PTY sessions for live terminals |
| **health-monitor** | Real-time diagnostics | System health, connection status |

## MCP Integration: Self-Aware Agents

Agor exposes itself as a **Model Context Protocol (MCP) server**, enabling agents to introspect and manipulate their own environment.

### Why MCP?

Instead of parsing CLI output:
```bash
# ❌ Brittle approach
$ agor session list | grep running | wc -l
```

Agents use **structured MCP tools** with typed responses:
```typescript
// ✅ Structured approach
→ agor_sessions_list({ status: 'running' })
← { total: 3, data: [...] }
```

### HTTP Transport

**Endpoint:** `POST /mcp?sessionToken={token}`
**Protocol:** JSON-RPC 2.0

Each session gets a unique token on creation (24h expiration), automatically injected into the agent's MCP config:

```typescript
mcpServers: {
  agor: {
    type: 'http',
    url: 'http://localhost:3030/mcp?sessionToken=cd5fc175...'
  }
}
```

### Available Tools (First Batch - Read-Only)

| Tool | Description | Example |
|------|-------------|---------|
| `agor_sessions_list` | List sessions with filters | `{ status: 'running', boardId: '...' }` |
| `agor_sessions_get` | Get specific session details | `{ sessionId: '01933e4a...' }` |
| `agor_sessions_get_current` | Get current session (introspection) | `{}` |
| `agor_worktrees_get` | Get worktree details | `{ worktreeId: '...' }` |
| `agor_worktrees_list` | List all worktrees | `{ limit: 10 }` |
| `agor_boards_get` | Get board by ID | `{ boardId: '...' }` |
| `agor_boards_list` | List all boards | `{}` |
| `agor_tasks_list` | List tasks in session | `{ sessionId: '...' }` |
| `agor_tasks_get` | Get specific task | `{ taskId: '...' }` |

### Example Agent Workflow

```
User: "What other sessions are running on this board?"

Agent thinking:
→ agor_sessions_get_current()
← { session_id: "019a1...", board_id: "019a2...", status: "running" }

→ agor_sessions_list({ boardId: "019a2...", status: "running" })
← { total: 3, data: [
    { session_id: "019a3...", agentic_tool: "claude-code", title: "Schema design" },
    { session_id: "019a4...", agentic_tool: "claude-code", title: "API implementation" }
  ]}

Agent: "There are 2 other sessions running on this board:
       - Session 019a3... (Claude Code, schema design)
       - Session 019a4... (Claude Code, API implementation)"
```

### Service Layer Integration

MCP tools route through **FeathersJS services** (not direct ORM) for:
- ✅ Consistent business logic
- ✅ Hook execution (validation, auth)
- ✅ Future RBAC support
- ✅ Cross-database compatibility

### Future: Write Operations (Second Batch)

Planned tools for multi-agent orchestration:
- `agor_sessions_create` - Create new session
- `agor_sessions_spawn` - Spawn child session (subtask delegation!)
- `agor_sessions_fork` - Fork session at specific point
- `agor_boards_create` - Create new board
- `agor_worktrees_create` - Create new worktree

**This will enable fully autonomous multi-agent workflows.**

## Data Architecture

### Hybrid Schema Strategy

Agor uses a **hybrid materialization approach** for cross-database compatibility (LibSQL → PostgreSQL):

**Materialized Columns** (indexed):
- Primary keys, foreign keys, status, timestamps
- Used for filtering, joins, sorting

**JSON Blobs** (flexible):
- Nested objects (git_state, genealogy, config)
- Arrays (tasks, contextFiles, children)
- Rarely queried metadata

**Benefits:**
- Migration-free schema evolution
- Fast indexed queries
- Cross-database compatibility (LibSQL ↔ PostgreSQL)

### Worktree-Based Isolation

Every session requires a worktree (foreign key constraint):

```
~/.agor/
├── agor.db              # Database
├── repos/               # Bare repositories
│   └── myapp/
└── worktrees/           # Session worktrees
    └── myapp/
        ├── main/        # Session 1 worktree
        └── feat-auth/   # Session 2 worktree
```

**Why worktrees?**
- Parallel development without branch switching
- Session isolation (no shared working directory)
- Natural mapping for fork/spawn operations

## Authentication

Three authentication strategies:

1. **Anonymous** (default) - No auth required for local development
2. **Local** (email/password) - JWT-based authentication
3. **JWT** - Token refresh and validation

All strategies use FeathersJS authentication with configurable storage.

## Next Steps

- **[Getting Started](/guide/getting-started)** - Install and run Agor
- **[API Reference](/api-reference)** - REST endpoints and WebSocket events
- **[CLI Reference](/cli)** - Command-line interface
